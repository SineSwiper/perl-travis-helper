#!/bin/bash
if [ -z "$MODERN_PERL" ]; then
  MODERN_PERL=perl
fi

[ -n "$CPAN_MIRROR" ] && export PERL_CPANM_OPT="--mirror $MIRROR"

function clean_up {
  kill $PROG
  wait 2>/dev/null
}

function cpanm_install {
  local dep="$1"
  printf "Installing (without testing) $dep ..."
  (
    while true; do
      sleep 3
      printf '.'
    done
  ) &
  local PROG=$!
  trap "clean_up $PROG; exit 1" SIGHUP SIGINT SIGTERM
  local OUT=$(cpanm --verbose --no-interactive --no-man-pages --notest --skip-satisfied $dep 2>&1 )
  local STATUS=$?
  kill $PROG
  wait $PROG 2>/dev/null
  trap - SIGHUP SIGINT SIGTERM
  if [ $STATUS != 0 ]; then
    echo ' Failed!'
    echo "$OUT"
    return $?
  fi
  echo ' Done'
}

function dynamic_deps {
  local AUTHOR_OPTS=''
  if [ -z "$AUTHOR_TESTING" ] || [ "$AUTHOR_TESTING" -ne 0 ]; then
    AUTHOR_OPTS='--with-recommends'
  fi
  cpanm --showdeps -q . --with-develop $AUTHOR_OPTS
}

function get_deps {
  local PHASE=$1
  local TYPE=$2
  local META_FILE
  for meta in MYMETA.* META.*; do
    META_FILE=$meta
  done
  if [ -z "$META_FILE" ]; then
    return
  fi
  $MODERN_PERL -MCPAN::Meta -e'
    my ($file, $phase, $type) = @ARGV;
    my $prereq = CPAN::Meta->load_file($file)->effective_prereqs;
    my $req = $prereq->requirements_for($phase, $type)->as_string_hash;
    for my $module (sort keys %$req) {
      next if $module eq "perl";
      my $version = $req->{$module};
      print $module . ($version ? "~$version" : "") . "\n";
    }
  ' $META_FILE $PHASE $TYPE
}

for arg; do
  case $arg in
    --deps)
      for dep in $(get_deps configure requires); do
        cpanm_install $dep || exit
      done

      for dep in $(dynamic_deps); do
        case $dep in
          perl*) ;;
          *)
            cpanm_install $dep || exit
          ;;
        esac
      done
    ;;
    --coverage)
      if [ -n "$COVERAGE" ]; then
        cpanm_install Devel::Cover || exit
        cpanm_install Devel::Cover::Report::Coveralls
      fi
    ;;
    *)
      cpanm_install $arg || exit
    ;;
  esac
done
